<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BPM Detector</title>
    <script type="module" defer>
      import { BeatTracker } from "./xa-beat-tracker.js";

      const fileInput = document.getElementById("fileInput");
      const playBtn = document.getElementById("playBtn");
      const stopBtn = document.getElementById("stopBtn");
      const analyzeBtn = document.getElementById("analyzeBtn");
      const bpmDisplay = document.getElementById("bpm");
      const logOutput = document.getElementById("logOutput");

      let audioContext, sourceNode, audioBuffer;
      const tracker = new BeatTracker();

      function logMessage(message) {
        const timestamp = new Date().toLocaleTimeString();
        logOutput.textContent += `[${timestamp}] ${message}\n`;
        logOutput.scrollTop = logOutput.scrollHeight;
      }

      function clearLog() {
        logOutput.textContent = "";
      }

      fileInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          clearLog();
          logMessage("Loading audio file...");
          
          audioContext = new AudioContext();
          const arrayBuffer = await file.arrayBuffer();
          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          
          bpmDisplay.textContent = "BPM: --";
          logMessage("‚úÖ Audio file loaded successfully");
          logMessage(`Duration: ${audioBuffer.duration.toFixed(1)}s, Sample Rate: ${audioBuffer.sampleRate}Hz`);
          
          playBtn.disabled = false;
          analyzeBtn.disabled = false;
          
        } catch (error) {
          console.error("File loading error:", error);
          bpmDisplay.textContent = "BPM: Error";
          logMessage("‚ùå Failed to load file: " + error.message);
        }
      });

      playBtn.onclick = async () => {
        if (!audioBuffer || !audioContext) {
          logMessage("‚ùå No audio loaded");
          return;
        }

        try {
          if (sourceNode) sourceNode.stop();

          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }

          sourceNode = audioContext.createBufferSource();
          sourceNode.buffer = audioBuffer;
          sourceNode.loop = true;
          sourceNode.connect(audioContext.destination);
          sourceNode.start();

          logMessage("‚ñ∂Ô∏è Audio playback started");
          playBtn.disabled = true;
          stopBtn.disabled = false;
          
        } catch (error) {
          console.error("Playback error:", error);
          logMessage("‚ùå Playback failed: " + error.message);
        }
      };

      stopBtn.onclick = () => {
        if (sourceNode) {
          sourceNode.stop();
          sourceNode = null;
        }
        logMessage("‚èπÔ∏è Audio playback stopped");
        playBtn.disabled = false;
        stopBtn.disabled = true;
      };

      analyzeBtn.onclick = async () => {
        if (!audioBuffer) return;

        try {
          analyzeBtn.disabled = true;
          playBtn.disabled = true;
          
          const y = audioBuffer.getChannelData(0);
          const sr = audioBuffer.sampleRate;

          // Use simpler, faster analysis for large files
          const isLargeFile = y.length > sr * 30; // More than 30 seconds
          const windowSize = isLargeFile ? 8.0 : 4.0;
          const hopSize = isLargeFile ? 2.0 : 1.0;

          bpmDisplay.textContent = "BPM: Analyzing...";
          clearLog();
          logMessage("üîç Starting BPM analysis");
          logMessage(`Audio: ${y.length.toLocaleString()} samples (${(y.length/sr).toFixed(1)}s)`);
          logMessage(`Window: ${windowSize}s, Hop: ${hopSize}s`);
          
          if (isLargeFile) {
            logMessage("‚ö° Large file detected - using optimized analysis");
          }

          const startTime = performance.now();
          
          // Run analysis with progress updates
          const result = await analyzeWithProgress(y, sr, windowSize, hopSize);
          
          const analysisTime = (performance.now() - startTime) / 1000;

          if (result.success) {
            const { times, tempo } = result;
            
            logMessage(`‚úÖ Analysis completed in ${analysisTime.toFixed(1)}s`);
            logMessage(`Found ${tempo.length} tempo readings:`);

            for (let i = 0; i < Math.min(times.length, 10); i++) {
              logMessage(`  [${i}] t=${times[i].toFixed(1)}s ‚Üí ${tempo[i].toFixed(1)} BPM`);
            }

            if (tempo.length > 10) {
              logMessage(`  ... and ${tempo.length - 10} more readings`);
            }

            const avgBpm = tempo.reduce((sum, bpm) => sum + bpm, 0) / tempo.length;
            const minBpm = Math.min(...tempo);
            const maxBpm = Math.max(...tempo);

            bpmDisplay.textContent = `BPM: ${avgBpm.toFixed(1)}`;
            logMessage(`üìä Average: ${avgBpm.toFixed(1)} BPM (range: ${minBpm.toFixed(1)}-${maxBpm.toFixed(1)})`);
          } else {
            throw new Error(result.error);
          }

        } catch (error) {
          console.error("Analysis error:", error);
          bpmDisplay.textContent = "BPM: Error";
          logMessage("‚ùå Analysis failed: " + error.message);
        } finally {
          analyzeBtn.disabled = false;
          playBtn.disabled = false;
        }
      };

      // Async analysis with progress updates
      async function analyzeWithProgress(y, sr, windowSize, hopSize) {
        try {
          const windowSamples = Math.floor(windowSize * sr);
          const hopSamples = Math.floor(hopSize * sr);
          const numWindows = Math.floor((y.length - windowSamples) / hopSamples);
          
          logMessage(`Processing ${numWindows} analysis windows...`);
          
          const dynamicTempo = [];
          const times = [];
          
          for (let i = 0; i < numWindows; i++) {
            const start = i * hopSamples;
            const window = y.slice(start, start + windowSamples);
            
            // Simplified tempo estimation to avoid freezing
            const tempo = await estimateTempoSimple(window, sr);
            
            dynamicTempo.push(tempo);
            times.push(start / sr);
            
            // Update progress every 10 windows and yield to browser
            if (i % 10 === 0) {
              const progress = ((i / numWindows) * 100).toFixed(0);
              logMessage(`Processing... ${progress}% (window ${i}/${numWindows})`);
              bpmDisplay.textContent = `BPM: ${progress}% analyzed`;
              
              // Yield to browser to prevent freezing
              await new Promise(resolve => setTimeout(resolve, 1));
            }
          }
          
          return { success: true, times, tempo: dynamicTempo };
          
        } catch (error) {
          return { success: false, error: error.message };
        }
      }

      // Simplified, fast tempo estimation
      async function estimateTempoSimple(audioWindow, sampleRate) {
        // Use autocorrelation on a smaller sample for speed
        const maxSamples = Math.min(audioWindow.length, sampleRate * 2); // Max 2 seconds
        const samples = audioWindow.slice(0, maxSamples);
        
        // Simplified onset detection - just use energy
        const frameSize = 1024;
        const hopSize = 512;
        const onsets = [];
        
        for (let i = 0; i < samples.length - frameSize; i += hopSize) {
          let energy = 0;
          for (let j = i; j < i + frameSize && j < samples.length; j++) {
            energy += samples[j] * samples[j];
          }
          onsets.push(Math.sqrt(energy));
        }
        
        // Simple peak detection for tempo
        const bpmRange = { min: 60, max: 200 };
        const lagRange = {
          min: Math.floor(60 * sampleRate / (bpmRange.max * hopSize)),
          max: Math.floor(60 * sampleRate / (bpmRange.min * hopSize))
        };
        
        let bestBpm = 120;
        let maxCorr = 0;
        
        // Simple autocorrelation
        for (let lag = lagRange.min; lag < Math.min(lagRange.max, onsets.length / 2); lag++) {
          let corr = 0;
          let count = 0;
          
          for (let i = 0; i < onsets.length - lag; i++) {
            corr += onsets[i] * onsets[i + lag];
            count++;
          }
          
          if (count > 0) {
            corr /= count;
            if (corr > maxCorr) {
              maxCorr = corr;
              bestBpm = 60 * sampleRate / (lag * hopSize);
            }
          }
        }
        
        // Constrain to reasonable range
        return Math.max(bpmRange.min, Math.min(bpmRange.max, bestBpm));
      }

      // Initialize
      playBtn.disabled = true;
      stopBtn.disabled = true;
      analyzeBtn.disabled = true;
    </script>

    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
        background: #f5f5f5;
      }

      .container {
        background: white;
        padding: 2rem;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 2rem;
      }

      #bpm {
        font-size: 2.5rem;
        font-weight: bold;
        text-align: center;
        margin: 1rem 0;
        padding: 1rem;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border-radius: 10px;
      }

      .controls {
        display: flex;
        gap: 1rem;
        justify-content: center;
        margin: 2rem 0;
        flex-wrap: wrap;
      }

      button, input[type="file"] {
        padding: 0.8rem 1.5rem;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1rem;
      }

      button {
        background: #007bff;
        color: white;
      }

      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      button:hover:not(:disabled) {
        background: #0056b3;
      }

      #analyzeBtn {
        background: #28a745;
      }

      #analyzeBtn:hover:not(:disabled) {
        background: #218838;
      }

      #stopBtn {
        background: #dc3545;
      }

      #stopBtn:hover:not(:disabled) {
        background: #c82333;
      }

      input[type="file"] {
        margin: 1rem 0;
        background: #f8f9fa;
        border: 2px dashed #dee2e6;
        width: 100%;
      }

      #logOutput {
        margin-top: 2rem;
        padding: 1rem;
        border: 1px solid #ddd;
        border-radius: 5px;
        height: 300px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 0.9rem;
        background: #f8f9fa;
        white-space: pre-wrap;
      }

      @media (max-width: 600px) {
        body {
          padding: 1rem;
        }
        
        .controls {
          flex-direction: column;
          align-items: center;
        }
        
        button {
          width: 100%;
          max-width: 200px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üéµ BPM Detector</h1>
      
      <div id="bpm">BPM: --</div>
      
      <input type="file" id="fileInput" accept="audio/*" />
      
      <div class="controls">
        <button id="playBtn">‚ñ∂Ô∏è Play</button>
        <button id="stopBtn">‚èπÔ∏è Stop</button>
        <button id="analyzeBtn">üîç Analyze BPM</button>
      </div>

      <div id="logOutput"></div>
    </div>
  </body>
</html>
