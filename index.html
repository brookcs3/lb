<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>🎵 Advanced BPM & Beat Detector</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="module" defer>
    import { BeatTracker, quickBeatTrack, beat_track, tempo, BeatTrackingUI } from './xa-beat-tracker.js';

    const fileInput = document.getElementById("fileInput");
    const playBtn = document.getElementById("playBtn");
    const stopBtn = document.getElementById("stopBtn");
    const analyzeBtn = document.getElementById("analyzeBtn");
    const clickTrackToggle = document.getElementById("clickTrackToggle");
    const bpmDisplay = document.getElementById("bpm");
    const logOutput = document.getElementById("logOutput");
    const waveformCanvas = document.getElementById("waveformCanvas");
    const playhead = document.getElementById("playhead");
    const progressBar = document.getElementById("progressBar");
    const tempoChartCanvas = document.getElementById("tempoChart");

    let audioContext, sourceNode, audioBuffer, beatTimes, onsetEnvelope, plpCurve;
    let animationFrame, tempoChart;
    const tracker = new BeatTracker();
    const ui = new BeatTrackingUI();

    function logMessage(message) {
      const timestamp = new Date().toLocaleTimeString();
      logOutput.textContent += `[${timestamp}] ${message}\n`;
      logOutput.scrollTop = logOutput.scrollHeight;
      console.log(`[${timestamp}] ${message}`);
    }

    function clearLog() {
      logOutput.textContent = "";
    }

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      try {
        clearLog();
        logMessage("Loading audio file...");
        audioContext = new AudioContext();
        const arrayBuffer = await file.arrayBuffer();
        audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        bpmDisplay.textContent = "BPM: --";
        logMessage("✅ Audio file loaded successfully");
        logMessage(`Duration: ${audioBuffer.duration.toFixed(1)}s, Sample Rate: ${audioBuffer.sampleRate}Hz`);
        playBtn.disabled = false;
        analyzeBtn.disabled = false;
        clickTrackToggle.disabled = false;
        drawWaveform();
      } catch (error) {
        console.error("File loading error:", error);
        bpmDisplay.textContent = "BPM: Error";
        logMessage("❌ Failed to load file: " + error.message);
      }
    });

    playBtn.onclick = async () => {
      if (!audioBuffer || !audioContext) {
        logMessage("❌ No audio loaded");
        return;
      }

      try {
        if (sourceNode) sourceNode.stop();
        if (audioContext.state === 'suspended') await audioContext.resume();
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = audioBuffer;
        sourceNode.loop = true;
        sourceNode.connect(audioContext.destination);

        if (clickTrackToggle.checked && beatTimes) {
          ui.playWithBeats(audioBuffer, beatTimes);
          logMessage("▶️ Playing audio with click track");
        } else {
          sourceNode.start();
          logMessage("▶️ Audio playback started");
        }

        playBtn.disabled = true;
        stopBtn.disabled = false;
        animatePlayhead();
      } catch (error) {
        console.error("Playback error:", error);
        logMessage("❌ Playback failed: " + error.message);
      }
    };

    stopBtn.onclick = () => {
      if (sourceNode) {
        sourceNode.stop();
        sourceNode = null;
      }
      logMessage("⏹️ Audio playback stopped");
      playBtn.disabled = false;
      stopBtn.disabled = true;
      stopAnimating();
    };

    analyzeBtn.onclick = async () => {
      if (!audioBuffer) return;

      try {
        analyzeBtn.disabled = true;
        playBtn.disabled = true;
        clickTrackToggle.disabled = true;
        progressBar.style.width = '0%';
        const y = audioBuffer.getChannelData(0);
        const sr = audioBuffer.sampleRate;
        const isLargeFile = y.length > sr * 30;
        const windowSize = isLargeFile ? 8.0 : 4.0;
        const hopSize = isLargeFile ? 2.0 : 1.0;

        bpmDisplay.textContent = "BPM: Analyzing...";
        clearLog();
        logMessage("🔍 Starting BPM and beat analysis");
        logMessage(`Audio: ${y.length.toLocaleString()} samples (${(y.length/sr).toFixed(1)}s)`);
        logMessage(`Window: ${windowSize}s, Hop: ${hopSize}s`);
        if (isLargeFile) logMessage("⚡ Large file detected - using optimized analysis");

        const startTime = performance.now();
        const result = await analyzeWithProgress(y, sr, windowSize, hopSize);
        const analysisTime = (performance.now() - startTime) / 1000;

        if (result.success) {
          const { times, tempo, globalTempo, confidence, candidates, tempogram, beats, plp } = result;
          beatTimes = beats;
          plpCurve = plp;

          logMessage(`✅ Analysis completed in ${analysisTime.toFixed(1)}s`);
          logMessage(`🎯 GLOBAL TEMPO: ${globalTempo.toFixed(1)} BPM (${(confidence * 100).toFixed(1)}% confidence)`);
          logMessage(`🥁 BEATS DETECTED: ${beats.length} at times ${beats.slice(0, 5).map(t => t.toFixed(2)).join(', ')}...`);
          logMessage(`📈 PLP Curve: ${plp.length} frames, max strength ${Math.max(...plp).toFixed(3)}`);

          // Display global tempo candidates
          logMessage(`🏆 Final global tempo candidates (raw autocorrelation):`);
          for (let i = 0; i < Math.min(candidates.length, 5); i++) {
            const candidate = candidates[i];
            const isWinner = Math.abs(candidate.bpm - globalTempo) < 0.1 ? "👑" : "";
            logMessage(` ${i+1}. ${candidate.bpm.toFixed(1)} BPM (score: ${candidate.score.toFixed(4)}) ${isWinner}`);
          }

          // Tempogram analysis
          logMessage(`📈 FOURIER TEMPOGRAM ANALYSIS:`);
          logMessage(` Time-frequency resolution: ${tempogram.frames} frames × ${tempogram.frequencies.length} frequencies`);
          logMessage(` Total spectral energy: ${tempogram.totalEnergy.toFixed(3)}`);
          if (tempogram.peakTempos.length > 0) {
            logMessage(`🎼 TEMPOGRAM PEAK TEMPOS:`);
            for (let i = 0; i < Math.min(tempogram.peakTempos.length, 8); i++) {
              const peak = tempogram.peakTempos[i];
              const globalMatch = Math.abs(peak.bpm - globalTempo) < 5 ? "🎯" : "";
              logMessage(` ${i+1}. ${peak.bpm.toFixed(1)} BPM (energy: ${peak.energy.toFixed(4)}, frames: ${peak.frameCount}/${tempogram.frames}, ${(peak.prominence*100).toFixed(1)}%) ${globalMatch}`);
            }
            const tempogramTop = tempogram.peakTempos[0];
            const agreementError = Math.abs(tempogramTop.bpm - globalTempo);
            logMessage(`🔍 Method agreement: Global=${globalTempo.toFixed(1)} vs Tempogram=${tempogramTop.bpm.toFixed(1)} BPM (±${agreementError.toFixed(1)})`);
            logMessage(agreementError < 5 ? `✅ EXCELLENT: Both methods agree within ±5 BPM` :
                       agreementError < 15 ? `⚠️ MODERATE: Methods agree within ±15 BPM` :
                       `❌ DISAGREEMENT: Methods differ by >15 BPM - complex tempo`);
          } else {
            logMessage(`❓ No clear peaks found in tempogram - complex/weak tempo`);
          }

          // Tempo stability
          const deviations = tempo.map(t => Math.abs(t - globalTempo));
          const avgDeviation = deviations.reduce((a, b) => a + b, 0) / deviations.length;
          const maxDeviation = Math.max(...deviations);
          logMessage(`📊 TEMPO STABILITY ANALYSIS:`);
          logMessage(` Average deviation: ±${avgDeviation.toFixed(1)} BPM`);
          logMessage(` Maximum deviation: ±${maxDeviation.toFixed(1)} BPM`);
          logMessage(` Stability windows: ${tempo.filter(t => Math.abs(t - globalTempo) < 5).length}/${tempo.length} stable (±5 BPM)`);

          // Window-by-window summary
          logMessage(`📈 WINDOW-BY-WINDOW SUMMARY:`);
          const stableCount = tempo.filter(t => Math.abs(t - globalTempo) < 5).length;
          const moderateCount = tempo.filter(t => Math.abs(t - globalTempo) >= 5 && Math.abs(t - globalTempo) < 15).length;
          const unstableCount = tempo.filter(t => Math.abs(t - globalTempo) >= 15).length;
          logMessage(` ✅ Stable (±5 BPM): ${stableCount} windows`);
          logMessage(` ⚠️ Moderate (5-15 BPM): ${moderateCount} windows`);
          logMessage(` ❌ Unstable (>15 BPM): ${unstableCount} windows`);

          // Final BPM display
          const stabilityStatus = avgDeviation < 5 ? "STABLE" : avgDeviation < 15 ? "MODERATE" : "UNSTABLE";
          const tempogramConfirmed = tempogram.peakTempos.length > 0 && Math.abs(tempogram.peakTempos[0].bpm - globalTempo) < 10;
          const displaySuffix = tempogramConfirmed ? "✓" : stabilityStatus;
          bpmDisplay.textContent = `BPM: ${globalTempo.toFixed(1)} (${displaySuffix})`;

          logMessage(`🎉 FINAL RESULT:`);
          if (confidence > 0.7 && tempogramConfirmed) {
            logMessage(`🎯 HIGH CONFIDENCE: Both methods confirm ${globalTempo.toFixed(1)} BPM`);
          } else if (confidence > 0.4) {
            logMessage(`⚠️ MODERATE CONFIDENCE: Track is likely ${globalTempo.toFixed(1)} BPM`);
          } else {
            logMessage(`❓ LOW CONFIDENCE: Complex/ambiguous tempo, best guess ${globalTempo.toFixed(1)} BPM`);
          }
          logMessage(`📊 Overall stability: ${stabilityStatus} (±${avgDeviation.toFixed(1)} BPM average)`);
          if (tempogram.peakTempos.length > 1) {
            logMessage(`🎼 Multiple tempo candidates detected - possible tempo changes or polyrhythm`);
          }

          // Render tempo and PLP chart
          renderTempoChart(times, tempo, plp, sr);
          drawWaveform(); // Redraw waveform with beat markers
        } else {
          throw new Error(result.error);
        }
      } catch (error) {
        console.error("Analysis error:", error);
        bpmDisplay.textContent = "BPM: Error";
        logMessage("❌ Analysis failed: " + error.message);
      } finally {
        analyzeBtn.disabled = false;
        playBtn.disabled = false;
        clickTrackToggle.disabled = false;
      }
    };


    async function analyzeWithProgress(y, sr, windowSize, hopSize) {
      try {
        logMessage(`🎵 Step 1: Computing onset strength and PLP...`);
        onsetEnvelope = tracker.onsetStrength(y, sr);
        plpCurve = tracker.plp({ y, sr });
        logMessage(`✅ Onset envelope: ${onsetEnvelope.length} frames, PLP: ${plpCurve.length} frames`);

        logMessage(`🎵 Step 2: Estimating global tempo...`);
        const globalTempo = await tempo(onsetEnvelope, sr);
        logMessage(`🎯 Global tempo (tempo fn): ${globalTempo.toFixed(1)} BPM`);

        logMessage(`🎵 Step 3: Detailed beat tracking...`);
        const beatResult = beat_track(y, sr, { units: 'time', sparse: true });
        logMessage(`🥁 Beat tracking: ${beatResult.beats.length} beats`);

        logMessage(`🎵 Step 4: Dynamic tempo analysis...`);
        const dynamicResult = tracker.estimateDynamicTempo(y, sr, windowSize, hopSize);
        const tempogramResult = await computeFourierTempogram(onsetEnvelope, sr);

        const windowSamples = Math.floor(windowSize * sr);
        const hopSamples = Math.floor(hopSize * sr);
        const numWindows = Math.floor((y.length - windowSamples) / hopSamples);

        for (let i = 0; i < numWindows; i++) {
          const progress = ((i / numWindows) * 100).toFixed(0);
          progressBar.style.width = `${progress}%`;
          await new Promise(resolve => setTimeout(resolve, 10));
        }

        return {
          success: true,
          times: dynamicResult.times,
          tempo: dynamicResult.tempo,
          globalTempo: globalTempo,
          confidence: 0.8, // Simplified for demo
          candidates: [], // Simplified, using tempo function
          tempogram: tempogramResult,
          beats: beatResult.beats,
          plp: plpCurve
        };
      } catch (error) {
        return { success: false, error: error.message };
      }
    }

    function renderTempoChart(times, tempo, plp, sr) {
      if (tempoChart) tempoChart.destroy();
      const ctx = tempoChartCanvas.getContext('2d');
      tempoChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: times,
          datasets: [
            {
              label: 'Dynamic Tempo (BPM)',
              data: tempo,
              borderColor: '#ff6384',
              backgroundColor: 'rgba(255, 99, 132, 0.2)',
              fill: false,
              tension: 0.4
            },
            {
              label: 'PLP Strength',
              data: plp,
              borderColor: '#36a2eb',
              backgroundColor: 'rgba(54, 162, 235, 0.2)',
              fill: false,
              tension: 0.4,
              yAxisID: 'y2'
            }
          ]
        },
        options: {
          scales: {
            x: { title: { display: true, text: 'Time (s)' } },
            y: { title: { display: true, text: 'Tempo (BPM)' }, beginAtZero: false },
            y2: {
              title: { display: true, text: 'PLP Strength' },
              position: 'right',
              beginAtZero: true,
              max: 1
            }
          },
          plugins: { title: { display: true, text: 'Dynamic Tempo & PLP' } }
        }
      });
    }

    function drawWaveform() {
      if (!audioBuffer) return;
      const canvas = waveformCanvas;
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);
      const channelData = audioBuffer.getChannelData(0);

      const minValue = Math.min(...channelData);
      const maxValue = Math.max(...channelData);
      const normalizedData = channelData.map(value => (value - minValue) / (maxValue - minValue));

      ctx.beginPath();
      ctx.moveTo(0, height / 2);
      for (let i = 0; i < width; i++) {
        const x = (i / width) * channelData.length;
        const y = height - ((normalizedData[Math.floor(x)] + 1) / 2 * height);
        ctx.lineTo(i, y);
      }
      ctx.strokeStyle = '#007bff';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw beat markers
      if (beatTimes) {
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 1;
        beatTimes.forEach(beatTime => {
          const x = (beatTime / audioBuffer.duration) * width;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        });
      }
    }

    function animatePlayhead() {
      if (!sourceNode || !audioBuffer) return;
      const currentTime = audioContext.currentTime;
      const playheadPosition = (currentTime % audioBuffer.duration) / audioBuffer.duration * waveformCanvas.width;
      playhead.style.left = `${playheadPosition}px`;
      animationFrame = requestAnimationFrame(animatePlayhead);
    }

    function stopAnimating() {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
      }
    }

    // Initialize
    playBtn.disabled = true;
    stopBtn.disabled = true;
    analyzeBtn.disabled = true;
    clickTrackToggle.disabled = true;
  </script>

  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      background: #f5f5f5;
    }

    .container {
      background: white;
      padding: 2rem;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 2rem;
    }

    #bpm {
      font-size: 2.5rem;
      font-weight: bold;
      text-align: center;
      margin: 1rem 0;
      padding: 1rem;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border-radius: 10px;
    }

    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin: 2rem 0;
      flex-wrap: wrap;
      align-items: center;
    }

    button, input[type="file"], input[type="checkbox"] {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
    }

    button {
      background: #007bff;
      color: white;
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    button:hover:not(:disabled) {
      background: #0056b3;
    }

    #analyzeBtn {
      background: #28a745;
    }

    #analyzeBtn:hover:not(:disabled) {
      background: #218838;
    }

    #stopBtn {
      background: #dc3545;
    }

    #stopBtn:hover:not(:disabled) {
      background: #c82333;
    }

    input[type="file"] {
      margin: 1rem 0;
      background: #f8f9fa;
      border: 2px dashed #dee2e6;
      width: 100%;
    }

    input[type="checkbox"] {
      width: auto;
      margin: 0 0.5rem;
    }

    #logOutput {
      margin-top: 2rem;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      height: 400px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.85rem;
      background: #f8f9fa;
      white-space: pre-wrap;
      line-height: 1.3;
    }

    #progressBar {
      height: 10px;
      background: #28a745;
      border-radius: 5px;
      transition: width 0.3s ease;
      margin-top: 1rem;
    }

    #progressContainer {
      background: #ddd;
      border-radius: 5px;
      height: 10px;
      margin-bottom: 1rem;
    }

    #waveformContainer, #tempoChartContainer {
      margin-top: 2rem;
      background: #f8f9fa;
      border-radius: 5px;
      overflow: hidden;
    }

    #waveformCanvas, #tempoChart {
      display: block;
      width: 100%;
      height: 200px;
    }

    #playhead {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 2px;
      background: #ff0000;
    }

    @media (max-width: 600px) {
      body {
        padding: 1rem;
      }
      .controls {
        flex-direction: column;
        align-items: center;
      }
      button, input[type="checkbox"] {
        width: 100%;
        max-width: 200px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>🎵 Advanced BPM & Beat Detector</h1>
    <div id="bpm">BPM: --</div>
    <input type="file" id="fileInput" accept="audio/*" />
    <div class="controls">
      <button id="playBtn">▶️ Play</button>
      <button id="stopBtn">⏹️ Stop</button>
      <button id="analyzeBtn">🔍 Analyze BPM & Beats</button>
      <label><input type="checkbox" id="clickTrackToggle">Play with Click Track</label>
    </div>
    <div id="progressContainer"><div id="progressBar" style="width: 0%"></div></div>
    <div id="logOutput"></div>
    <div id="waveformContainer">
      <canvas id="waveformCanvas"></canvas>
      <div id="playhead"></div>
    </div>
    <div id="tempoChartContainer">
      <canvas id="tempoChart"></canvas>
    </div>
  </div>
</body>
</html>
